{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Py-ART Basics Overview Within this notebook, we will cover: General overview of Py-ART and its functionality Reading data using Py-ART An overview of the pyart.Radar object Create a Plot of our Radar Data Prerequisites Concepts Importance Notes Cartopy Helpful Basic features Matplotlib Helpful Basic plotting NumPy Helpful Basic arrays Imports # import os import warnings import cartopy.crs as ccrs import matplotlib.pyplot as plt import numpy as np import pyart warnings . filterwarnings ( 'ignore' ) An Overview of Py-ART History of the Py-ART Development began to address the needs of ARM with the acquisition of a number of new scanning cloud and precipitation radar as part of the American Recovery Act. The project has since expanded to work with a variety of weather radars and a wider user base including radar researchers and climate modelers. The software has been released on GitHub as open source software under a BSD license. Runs on Linux, OS X. It also runs on Windows with more limited functionality. What can PyART Do? Py-ART can be used for a variety of tasks from basic plotting to more complex processing pipelines. Specific uses for Py-ART include: Reading radar data in a variety of file formats. Creating plots and visualization of radar data. Correcting radar moments while in antenna coordinates, such as: Doppler unfolding/de-aliasing. Attenuation correction. Phase processing using a Linear Programming method. Mapping data from one or multiple radars onto a Cartesian grid. Performing retrievals. Writing radial and Cartesian data to NetCDF files. Reading in Data Using Py-ART When reading in a radar file, we use the pyart.io.read module. pyart.io.read can read a variety of different radar formats, such as Cf/Radial, LASSEN, and more. The documentation on what formats can be read by Py-ART can be found here: Py-ART IO Documentation For most file formats listed on the page, using pyart.io.read should suffice since Py-ART has the ability to automatically detect the file format. Let's check out what arguments arguments pyart.io.read() takes in! pyart . io . read ? Let 's use a sample data file from `pyart` - which is [**cfradial** format](https://github.com/NCAR/CfRadial). When we read this in , we get a [ ` pyart . Radar ` object ]( https : // arm - doe . github . io / pyart / API / generated / pyart . core . Radar . html #pyart.core.Radar)! file = '../data/sample_sail_ppi.nc' radar = pyart . io . read ( file ) radar Investigate the pyart.Radar object This is where data such as reflectivity and velocity are stored. To see what fields are present we can add the fields and keys additions to the variable where the radar object is stored. radar . fields . keys () dict_keys ([ 'corrected_velocity' , 'corrected_reflectivity' , 'corrected_differential_reflectivity' , 'corrected_specific_diff_phase' , 'corrected_differential_phase' ]) Extract a sample data field The fields are stored in a dictionary, each containing coordinates, units and more. All can be accessed by just adding the fields addition to the radar object variable. For an individual field, we add a string in brackets after the fields addition to see the contents of that field. Let\u2019s take a look at corrected_reflectivity , which is a common field to investigate. print ( radar . fields [ 'corrected_reflectivity' ]) # Output { '_FillValue' : 1e+20 , 'long_name' : 'Corrected reflectivity' , 'units' : 'dBZ' , 'standard_name' : 'corrected_equivalent_reflectivity_factor' , 'coordinates' : 'elevation azimuth range' , 'data' : masked_array ( data = [[ -- , -- , -- , ... , -- , -- , -- ], [ -- , -- , -- , ... , -- , -- , -- ], [ -- , -- , -- , ... , -- , -- , -- ], ... , [ 12.25 , 9.84000015258789 , 14.210000038146973 , ... , -- , -- , -- ], [ 11.5 , 9.729999542236328 , 11.75999927520752 , ... , -- , -- , -- ], [ 11.069999694824219 , 10.329999923706055 , 10.050000190734863 , ... , -- , -- , -- ]], mask = [[ True , True , True , ... , True , True , True ], [ True , True , True , ... , True , True , True ], [ True , True , True , ... , True , True , True ], ... , [ False , False , False , ... , True , True , True ], [ False , False , False , ... , True , True , True ], [ False , False , False , ... , True , True , True ]], fill_value = 1e+20 )} We can go even further in the dictionary and access the actual reflectivity data. We use add data at the end, which will extract the data array (which is a masked numpy array) from the dictionary. reflectivity = radar . fields [ 'corrected_reflectivity' ][ 'data' ] print ( type ( reflectivity ), reflectivity ) Lets\u2019 check the size of this array\u2026 reflectivity . shape # Output 9013 668 This reflectivity data array, numpy array, is a two-dimensional array with dimensions: Gates (number of samples away from the radar) Rays (direction around the radar) print ( radar . nrays , radar . ngates ) #Output 9013 668 If we wanted to look the 300th ray, at the second gate, we would use something like the following: print ( reflectivity [ 300 , 2 ]) 9.369999885559082 Plotting our Radar Data An Overview of Py-ART Plotting Utilities Now that we have loaded the data and inspected it, the next logical thing to do is to visualize the data! Py-ART\u2019s visualization functionality is done through the objects in the pyart.graph module. In Py-ART there are 4 primary visualization classes in pyart.graph: RadarDisplay RadarMapDisplay AirborneRadarDisplay Plotting grid data GridMapDisplay Use the RadarMapDisplay with our data For the this example, we will be using RadarMapDisplay, using Cartopy to deal with geographic coordinates. We start by creating a figure first. fig = plt . figure ( figsize = [ 10 , 10 ]) #Output < Figure size 1000 x1000 with 0 Axes > Once we have a figure, let\u2019s add our RadarMapDisplay fig = plt . figure ( figsize = [ 10 , 10 ]) display = pyart . graph . RadarMapDisplay ( radar ) < Figure size 1000 x1000 with 0 Axes > Adding our map display without specifying a field to plot won\u2019t do anything we need to specifically add a field to field using .plot_ppi_map() , which creates a Plan Position Indicator (PPI) plot. display . plot_ppi_map ( 'corrected_reflectivity' ) By default, it will plot the elevation scan, the the default colormap from Matplotlib\u2026 let\u2019s customize! We add the following arguements: sweep=3 - The fourth elevation scan (since we are using Python indexing) vmin=-20 - Minimum value for our plotted field/colorbar vmax=60 - Maximum value for our plotted field/colorbar projection=ccrs.PlateCarree() - Cartopy latitude/longitude coordinate system cmap='pyart_HomeyerRainbow' - Colormap to use, selecting one provided by PyART of lat_lines - Which lines to plot for latitude lon_lines - Which liens to plot for longitude ###### fig = plt.figure(figsize=[12, 8]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 3 , vmin =- 20 , vmax = 60 , lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), projection = ccrs . PlateCarree (), cmap = 'pyart_HomeyerRainbow' ) plt . show () You can change many parameters in the graph by changing the arguments to plot_ppi_map. As you can recall from earlier. simply view these arguments in a Jupyter notebook by typing: display . plot_ppi_map ? For example, let\u2019s change the colormap to something different fig = plt . figure ( figsize = [ 12 , 8 ]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 3 , vmin =- 20 , vmax = 60 , projection = ccrs . PlateCarree (), lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), cmap = 'pyart_Carbone42' ) plt . show () Or, let\u2019s view a different elevation scan! To do this, change the sweep parameter in the plot_ppi_map function. fig = plt . figure ( figsize = [ 12 , 8 ]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 6 , vmin =- 20 , vmax = 60 , lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), projection = ccrs . PlateCarree (), cmap = 'pyart_Carbone42' ) plt . show () Plotting an RHI Another common plot that is requested by the radar community is a Range Height Indicator (RHI) Plot. Fortunately, Py-ART has a utility to help us create one of these from our radar! During this same time period during SAIL, the ARM program collected RHI scans, which provide a vertical cross section through the preciptiation! Let\u2019s read in one of those files. The IO line is the same! Read in an RHI file rhi_file = '../data/sample_sail_rhi.nc' rhi_radar = pyart . io . read ( rhi_file ) Plot our RHI We want to use the RadarDisplay here to visualize, using the reflectivity field ( DBZ ) Note - this is uncorrected data, so be sure take caution working with this radar = pyart . graph . RadarDisplay ( rhi_radar ) radar . plot ( \"DBZ\" , vmin =- 20 , vmax = 60 ,) plt . ylim ( 0 , 5 ); Add a \u201cPseudo-RHI\u201d from our PPI data But let\u2019s say we wanted to compare the vertical resolution we get from an RHI, compared to PPI\u2026 we can do this with Py-ART! # Load our PPI data back in file = '../data/sample_sail_ppi.nc' radar = pyart . io . read ( file ) radar # Create a cross section at our 334 degree azimuth xsect = pyart . util . cross_section_ppi ( radar , [ 328 ]) Now, notice how coarse the resolution of the precipitation region! colorbar_label = 'Equivalent \\n reflectivity factor \\n (dBZ)' display = pyart . graph . RadarDisplay ( xsect ) display . plot ( 'corrected_reflectivity' , 0 , vmin =- 20 , vmax = 60 , colorbar_label = colorbar_label ) plt . ylim ( 0 , 5 ) plt . tight_layout () Note Py-ART can be used for a variety of tasks from basic plotting to more complex processing pipelines. Specific uses for Py-ART include: \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"Python Radar Toolkit"},{"location":"#py-art-basics","text":"","title":"Py-ART Basics"},{"location":"#overview","text":"Within this notebook, we will cover: General overview of Py-ART and its functionality Reading data using Py-ART An overview of the pyart.Radar object Create a Plot of our Radar Data","title":"Overview"},{"location":"#prerequisites","text":"Concepts Importance Notes Cartopy Helpful Basic features Matplotlib Helpful Basic plotting NumPy Helpful Basic arrays","title":"Prerequisites"},{"location":"#imports","text":"# import os import warnings import cartopy.crs as ccrs import matplotlib.pyplot as plt import numpy as np import pyart warnings . filterwarnings ( 'ignore' )","title":"Imports"},{"location":"#an-overview-of-py-art","text":"","title":"An Overview of Py-ART"},{"location":"#history-of-the-py-art","text":"Development began to address the needs of ARM with the acquisition of a number of new scanning cloud and precipitation radar as part of the American Recovery Act. The project has since expanded to work with a variety of weather radars and a wider user base including radar researchers and climate modelers. The software has been released on GitHub as open source software under a BSD license. Runs on Linux, OS X. It also runs on Windows with more limited functionality.","title":"History of the Py-ART"},{"location":"#what-can-pyart-do","text":"Py-ART can be used for a variety of tasks from basic plotting to more complex processing pipelines. Specific uses for Py-ART include: Reading radar data in a variety of file formats. Creating plots and visualization of radar data. Correcting radar moments while in antenna coordinates, such as: Doppler unfolding/de-aliasing. Attenuation correction. Phase processing using a Linear Programming method. Mapping data from one or multiple radars onto a Cartesian grid. Performing retrievals. Writing radial and Cartesian data to NetCDF files.","title":"What can PyART Do?"},{"location":"#reading-in-data-using-py-art","text":"When reading in a radar file, we use the pyart.io.read module. pyart.io.read can read a variety of different radar formats, such as Cf/Radial, LASSEN, and more. The documentation on what formats can be read by Py-ART can be found here: Py-ART IO Documentation For most file formats listed on the page, using pyart.io.read should suffice since Py-ART has the ability to automatically detect the file format. Let's check out what arguments arguments pyart.io.read() takes in! pyart . io . read ? Let 's use a sample data file from `pyart` - which is [**cfradial** format](https://github.com/NCAR/CfRadial). When we read this in , we get a [ ` pyart . Radar ` object ]( https : // arm - doe . github . io / pyart / API / generated / pyart . core . Radar . html #pyart.core.Radar)! file = '../data/sample_sail_ppi.nc' radar = pyart . io . read ( file ) radar","title":"Reading in Data Using Py-ART"},{"location":"#investigate-the-pyartradar-object","text":"This is where data such as reflectivity and velocity are stored. To see what fields are present we can add the fields and keys additions to the variable where the radar object is stored. radar . fields . keys () dict_keys ([ 'corrected_velocity' , 'corrected_reflectivity' , 'corrected_differential_reflectivity' , 'corrected_specific_diff_phase' , 'corrected_differential_phase' ])","title":"Investigate the pyart.Radar object"},{"location":"#extract-a-sample-data-field","text":"The fields are stored in a dictionary, each containing coordinates, units and more. All can be accessed by just adding the fields addition to the radar object variable. For an individual field, we add a string in brackets after the fields addition to see the contents of that field. Let\u2019s take a look at corrected_reflectivity , which is a common field to investigate. print ( radar . fields [ 'corrected_reflectivity' ]) # Output { '_FillValue' : 1e+20 , 'long_name' : 'Corrected reflectivity' , 'units' : 'dBZ' , 'standard_name' : 'corrected_equivalent_reflectivity_factor' , 'coordinates' : 'elevation azimuth range' , 'data' : masked_array ( data = [[ -- , -- , -- , ... , -- , -- , -- ], [ -- , -- , -- , ... , -- , -- , -- ], [ -- , -- , -- , ... , -- , -- , -- ], ... , [ 12.25 , 9.84000015258789 , 14.210000038146973 , ... , -- , -- , -- ], [ 11.5 , 9.729999542236328 , 11.75999927520752 , ... , -- , -- , -- ], [ 11.069999694824219 , 10.329999923706055 , 10.050000190734863 , ... , -- , -- , -- ]], mask = [[ True , True , True , ... , True , True , True ], [ True , True , True , ... , True , True , True ], [ True , True , True , ... , True , True , True ], ... , [ False , False , False , ... , True , True , True ], [ False , False , False , ... , True , True , True ], [ False , False , False , ... , True , True , True ]], fill_value = 1e+20 )} We can go even further in the dictionary and access the actual reflectivity data. We use add data at the end, which will extract the data array (which is a masked numpy array) from the dictionary. reflectivity = radar . fields [ 'corrected_reflectivity' ][ 'data' ] print ( type ( reflectivity ), reflectivity ) Lets\u2019 check the size of this array\u2026 reflectivity . shape # Output 9013 668 This reflectivity data array, numpy array, is a two-dimensional array with dimensions: Gates (number of samples away from the radar) Rays (direction around the radar) print ( radar . nrays , radar . ngates ) #Output 9013 668 If we wanted to look the 300th ray, at the second gate, we would use something like the following: print ( reflectivity [ 300 , 2 ]) 9.369999885559082","title":"Extract a sample data field"},{"location":"#plotting-our-radar-data","text":"","title":"Plotting our Radar Data"},{"location":"#an-overview-of-py-art-plotting-utilities","text":"Now that we have loaded the data and inspected it, the next logical thing to do is to visualize the data! Py-ART\u2019s visualization functionality is done through the objects in the pyart.graph module. In Py-ART there are 4 primary visualization classes in pyart.graph: RadarDisplay RadarMapDisplay AirborneRadarDisplay Plotting grid data GridMapDisplay","title":"An Overview of Py-ART Plotting Utilities"},{"location":"#use-the-radarmapdisplay-with-our-data","text":"For the this example, we will be using RadarMapDisplay, using Cartopy to deal with geographic coordinates. We start by creating a figure first. fig = plt . figure ( figsize = [ 10 , 10 ]) #Output < Figure size 1000 x1000 with 0 Axes > Once we have a figure, let\u2019s add our RadarMapDisplay fig = plt . figure ( figsize = [ 10 , 10 ]) display = pyart . graph . RadarMapDisplay ( radar ) < Figure size 1000 x1000 with 0 Axes > Adding our map display without specifying a field to plot won\u2019t do anything we need to specifically add a field to field using .plot_ppi_map() , which creates a Plan Position Indicator (PPI) plot. display . plot_ppi_map ( 'corrected_reflectivity' ) By default, it will plot the elevation scan, the the default colormap from Matplotlib\u2026 let\u2019s customize! We add the following arguements: sweep=3 - The fourth elevation scan (since we are using Python indexing) vmin=-20 - Minimum value for our plotted field/colorbar vmax=60 - Maximum value for our plotted field/colorbar projection=ccrs.PlateCarree() - Cartopy latitude/longitude coordinate system cmap='pyart_HomeyerRainbow' - Colormap to use, selecting one provided by PyART of lat_lines - Which lines to plot for latitude lon_lines - Which liens to plot for longitude ###### fig = plt.figure(figsize=[12, 8]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 3 , vmin =- 20 , vmax = 60 , lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), projection = ccrs . PlateCarree (), cmap = 'pyart_HomeyerRainbow' ) plt . show () You can change many parameters in the graph by changing the arguments to plot_ppi_map. As you can recall from earlier. simply view these arguments in a Jupyter notebook by typing: display . plot_ppi_map ? For example, let\u2019s change the colormap to something different fig = plt . figure ( figsize = [ 12 , 8 ]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 3 , vmin =- 20 , vmax = 60 , projection = ccrs . PlateCarree (), lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), cmap = 'pyart_Carbone42' ) plt . show () Or, let\u2019s view a different elevation scan! To do this, change the sweep parameter in the plot_ppi_map function. fig = plt . figure ( figsize = [ 12 , 8 ]) display = pyart . graph . RadarMapDisplay ( radar ) display . plot_ppi_map ( 'corrected_reflectivity' , sweep = 6 , vmin =- 20 , vmax = 60 , lat_lines = np . arange ( 38 , 39.5 , .25 ), lon_lines = np . arange ( - 107.5 , - 106.5 , .25 ), projection = ccrs . PlateCarree (), cmap = 'pyart_Carbone42' ) plt . show ()","title":"Use the RadarMapDisplay with our data"},{"location":"#plotting-an-rhi","text":"Another common plot that is requested by the radar community is a Range Height Indicator (RHI) Plot. Fortunately, Py-ART has a utility to help us create one of these from our radar! During this same time period during SAIL, the ARM program collected RHI scans, which provide a vertical cross section through the preciptiation! Let\u2019s read in one of those files. The IO line is the same!","title":"Plotting an RHI"},{"location":"#read-in-an-rhi-file","text":"rhi_file = '../data/sample_sail_rhi.nc' rhi_radar = pyart . io . read ( rhi_file )","title":"Read in an RHI file"},{"location":"#plot-our-rhi","text":"We want to use the RadarDisplay here to visualize, using the reflectivity field ( DBZ ) Note - this is uncorrected data, so be sure take caution working with this radar = pyart . graph . RadarDisplay ( rhi_radar ) radar . plot ( \"DBZ\" , vmin =- 20 , vmax = 60 ,) plt . ylim ( 0 , 5 );","title":"Plot our RHI"},{"location":"#add-a-pseudo-rhi-from-our-ppi-data","text":"But let\u2019s say we wanted to compare the vertical resolution we get from an RHI, compared to PPI\u2026 we can do this with Py-ART! # Load our PPI data back in file = '../data/sample_sail_ppi.nc' radar = pyart . io . read ( file ) radar # Create a cross section at our 334 degree azimuth xsect = pyart . util . cross_section_ppi ( radar , [ 328 ]) Now, notice how coarse the resolution of the precipitation region! colorbar_label = 'Equivalent \\n reflectivity factor \\n (dBZ)' display = pyart . graph . RadarDisplay ( xsect ) display . plot ( 'corrected_reflectivity' , 0 , vmin =- 20 , vmax = 60 , colorbar_label = colorbar_label ) plt . ylim ( 0 , 5 ) plt . tight_layout () Note Py-ART can be used for a variety of tasks from basic plotting to more complex processing pipelines. Specific uses for Py-ART include: \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"Add a \u201cPseudo-RHI\u201d from our PPI data"},{"location":"numpy/","text":"Statistics Statistics is the discipline that studies the collection , organization , displaying , analysis , interpretation and presentation of data. Statistics is a branch of mathematics that is recommended to be a prerequisite for data science and machine learning. Statistics is a very broad field but we will focus in this section only on the most relevant part. After completing this challenge, you may go to web development, data analysis, machine learning and data science path. Whatever path you may follow, at some point in your career you will get data which you may work on. Having some statistical knowledge will help you to make decision based on data, data tells as they say . Data What is data? Data is any set of characters that is gathered and translated for some purpose, usually analysis. It can be any character, including text and numbers, pictures, sound, or video. If data is not put into context, it doesn't give any sense to a human or computer. To make sense from data we need to work on the data using different tools. The work flow of data analysis, data science or machine learning starts from data. Data can be provided from some data source or it can be created. There are structured and and unstructure data. Data can be found as small or big data format. Most of the data types we will get have been covered in the file handling section. Statistics Module The python statistics module provides functions for calculating mathematical statistics of numeric data. The module is not intended to be a competitor to third-party libraries such as NumPy, SciPy, or proprietary full-featured statistics packages aimed at professional statisticians such as Minitab, SAS and Matlab. It is aimed at the level of graphing and scientific calculators. NumPy In the first section we defined python as a great general-purpose programming language on its own, but with the help of other popular libraries (numpy, scipy, matplotlib, pandas etc) it becomes a powerful environment for scientific computing. Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with arrays. So far, we have been using vscode but from now on I would recommend using Jupyter Notebook. To access jupter notebook let's install anaconda . If you are using anaconda most of the common packages are included and you don't have install packages if you installed anaconda. asabeneh@Asabeneh:~/Desktop/30DaysOfPython$ pip install numpy Importing NumPy Jupyter notebook is available if your are in favor of jupyter notebook # How to import numpy import numpy as np # How to check the version of the numpy package print ( 'numpy:' , np . __version__ ) # Checking the available methods print ( dir ( np )) Creating numpy array using Creating int numpy arrays # Creating python List python_list = [ 1 , 2 , 3 , 4 , 5 ] # Checking data types print ( 'Type:' , type ( python_list )) # <class 'list'> # print ( python_list ) # [1, 2, 3, 4, 5] two_dimensional_list = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]] print ( two_dimensional_list ) # [[0, 1, 2], [3, 4, 5], [6, 7, 8]] # Creating Numpy(Numerical Python) array from python list numpy_array_from_list = np . array ( python_list ) print ( type ( numpy_array_from_list )) # <class 'numpy.ndarray'> print ( numpy_array_from_list ) # array([1, 2, 3, 4, 5]) Creating float numpy arrays Creating a float numpy array from list with a float data type parameter # Python list python_list = [ 1 , 2 , 3 , 4 , 5 ] numy_array_from_list2 = np . array ( python_list , dtype = float ) print ( numy_array_from_list2 ) # array([1., 2., 3., 4., 5.]) Creating boolean numpy arrays Creating a boolean a numpy array from list numpy_bool_array = np . array ([ 0 , 1 , - 1 , 0 , 0 ], dtype = bool ) print ( numpy_bool_array ) # array([False, True, True, False, False]) Creating multidimensional array using numpy A numpy array may have one or multiple rows and columns two_dimensional_list = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]] numpy_two_dimensional_list = np . array ( two_dimensional_list ) print ( type ( numpy_two_dimensional_list )) print ( numpy_two_dimensional_list ) <class 'numpy.ndarray' > [[ 0 1 2 ] [ 3 4 5 ] [ 6 7 8 ]] Converting numpy array to list # We can always convert an array back to a python list using tolist(). np_to_list = numpy_array_from_list . tolist () print ( type ( np_to_list )) print ( 'one dimensional array:' , np_to_list ) print ( 'two dimensional array: ' , numpy_two_dimensional_list . tolist ()) <class 'list' > one dimensional array: [ 1 , 2 , 3 , 4 , 5 ] two dimensional array: [[ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ]] Creating numpy array from tuple # Numpy array from tuple # Creating tuple in Python python_tuple = ( 1 , 2 , 3 , 4 , 5 ) print ( type ( python_tuple )) # <class 'tuple'> print ( 'python_tuple: ' , python_tuple ) # python_tuple: (1, 2, 3, 4, 5) numpy_array_from_tuple = np . array ( python_tuple ) print ( type ( numpy_array_from_tuple )) # <class 'numpy.ndarray'> print ( 'numpy_array_from_tuple: ' , numpy_array_from_tuple ) # numpy_array_from_tuple: [1 2 3 4 5] Shape of numpy array The shape method provide the shape of the array as a tuple. The first is the row and the second is the column. If the array is just one dimensional it returns the size of the array. nums = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( nums ) print ( 'shape of nums: ' , nums . shape ) print ( numpy_two_dimensional_list ) print ( 'shape of numpy_two_dimensional_list: ' , numpy_two_dimensional_list . shape ) three_by_four_array = np . array ([[ 0 , 1 , 2 , 3 ], [ 4 , 5 , 6 , 7 ], [ 8 , 9 , 10 , 11 ]]) print ( three_by_four_array . shape ) [ 1 2 3 4 5 ] shape of nums: ( 5 , ) [[ 0 1 2 ] [ 3 4 5 ] [ 6 7 8 ]] shape of numpy_two_dimensional_list: ( 3 , 3 ) ( 3 , 4 ) Data type of numpy array Type of data types: str, int, float, complex, bool, list, None int_lists = [ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ] int_array = np . array ( int_lists ) float_array = np . array ( int_lists , dtype = float ) print ( int_array ) print ( int_array . dtype ) print ( float_array ) print ( float_array . dtype ) [ -3 -2 -1 0 1 2 3 ] int64 [ -3. -2. -1. 0 . 1 . 2 . 3 . ] float64 Size of a numpy array In numpy to know the number of items in a numpy array list we use size numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) two_dimensional_list = np . array ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]]) print ( 'The size:' , numpy_array_from_list . size ) # 5 print ( 'The size:' , two_dimensional_list . size ) # 3 The size: 5 The size: 9 Mathematical Operation using numpy Numpy array is not like exactly like python list. To do mathematical operation in pyhton list we have to loop through the items but numpy can allow to do any mathematical operation without looping. Mathematical Operation: Addition (+) Subtraction (-) Multiplication (*) Division (/) Modules (%) Floor Division(//) Exponential(**) Addition # Mathematical Operation # Addition numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_plus_original = numpy_array_from_list + 10 print ( ten_plus_original ) original array: [ 1 2 3 4 5 ] [ 11 12 13 14 15 ] Subtraction # Subtraction numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_minus_original = numpy_array_from_list - 10 print ( ten_minus_original ) original array: [ 1 2 3 4 5 ] [ -9 -8 -7 -6 -5 ] Multiplication # Multiplication numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list * 10 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 10 20 30 40 50 ] Division # Division numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list / 10 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 0 .1 0 .2 0 .3 0 .4 0 .5 ] Modulus # Modulus; Finding the remainder numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list % 3 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 1 2 0 1 2 ] Floor Division # Floor division: the division result without the remainder numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list // 10 print ( ten_times_original ) Exponential # Exponential is finding some number the power of another: numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list ** 2 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 1 4 9 16 25 ] Checking data types #Int, Float numbers numpy_int_arr = np . array ([ 1 , 2 , 3 , 4 ]) numpy_float_arr = np . array ([ 1.1 , 2.0 , 3.2 ]) numpy_bool_arr = np . array ([ - 3 , - 2 , 0 , 1 , 2 , 3 ], dtype = 'bool' ) print ( numpy_int_arr . dtype ) print ( numpy_float_arr . dtype ) print ( numpy_bool_arr . dtype ) int64 float64 bool Converting types We can convert the data types of numpy array Int to Float numpy_int_arr = np . array ([ 1 , 2 , 3 , 4 ], dtype = 'float' ) numpy_int_arr array([1., 2., 3., 4.]) Float to Int numpy_int_arr = np . array ([ 1. , 2. , 3. , 4. ], dtype = 'int' ) numpy_int_arr array ([ 1 , 2 , 3 , 4 ]) Int ot boolean np . array ([ - 3 , - 2 , 0 , 1 , 2 , 3 ], dtype = 'bool' ) array ([ True, True, False, True, True, True ]) Int to str numpy_float_list . astype ( 'int' ) . astype ( 'str' ) array ([ '1' , '2' , '3' ] , dtype = '<U21' ) Multi-dimensional Arrays # 2 Dimension Array two_dimension_array = np . array ([( 1 , 2 , 3 ),( 4 , 5 , 6 ), ( 7 , 8 , 9 )]) print ( type ( two_dimension_array )) print ( two_dimension_array ) print ( 'Shape: ' , two_dimension_array . shape ) print ( 'Size:' , two_dimension_array . size ) print ( 'Data type:' , two_dimension_array . dtype ) <class 'numpy.ndarray' > [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]] Shape: ( 3 , 3 ) Size: 9 Data type: int64 Getting items from a numpy array # 2 Dimension Array two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) first_row = two_dimension_array [ 0 ] second_row = two_dimension_array [ 1 ] third_row = two_dimension_array [ 2 ] print ( 'First row:' , first_row ) print ( 'Second row:' , second_row ) print ( 'Third row: ' , third_row ) First row: [ 1 2 3 ] Second row: [ 4 5 6 ] Third row: [ 7 8 9 ] first_column = two_dimension_array [:, 0 ] second_column = two_dimension_array [:, 1 ] third_column = two_dimension_array [:, 2 ] print ( 'First column:' , first_column ) print ( 'Second column:' , second_column ) print ( 'Third column: ' , third_column ) print ( two_dimension_array ) First column: [ 1 4 7 ] Second column: [ 2 5 8 ] Third column: [ 3 6 9 ] [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]] Slicing Numpy array Slicing in numpy is similar to slicing in python list two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) first_two_rows_and_columns = two_dimension_array [ 0 : 2 , 0 : 2 ] print ( first_two_rows_and_columns ) [[ 1 2 ] [ 4 5 ]] How to reverse the rows and the whole array? two_dimension_array [::] array ([[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ]]) Reverse the row and column positions two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) two_dimension_array [:: - 1 ,:: - 1 ] array ([[ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] , [ 3 , 2 , 1 ]]) How to represent missing values ? print ( two_dimension_array ) two_dimension_array [ 1 , 1 ] = 55 two_dimension_array [ 1 , 2 ] = 44 print ( two_dimension_array ) [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]] [[ 1 2 3 ] [ 4 55 44 ] [ 7 8 9 ]] # Numpy Zeroes # numpy.zeros(shape, dtype=float, order='C') numpy_zeroes = np . zeros (( 3 , 3 ), dtype = int , order = 'C' ) numpy_zeroes array ([[ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ]]) # Numpy Zeroes numpy_ones = np . ones (( 3 , 3 ), dtype = int , order = 'C' ) print ( numpy_ones ) [[ 1 1 1 ] [ 1 1 1 ] [ 1 1 1 ]] twoes = numpy_ones * 2 # Reshape # numpy.reshape(), numpy.flatten() first_shape = np . array ([( 1 , 2 , 3 ), ( 4 , 5 , 6 )]) print ( first_shape ) reshaped = first_shape . reshape ( 3 , 2 ) print ( reshaped ) [[ 1 2 3 ] [ 4 5 6 ]] [[ 1 2 ] [ 3 4 ] [ 5 6 ]] flattened = reshaped . flatten () flattened array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) ## Horitzontal Stack np_list_one = np . array ([ 1 , 2 , 3 ]) np_list_two = np . array ([ 4 , 5 , 6 ]) print ( np_list_one + np_list_two ) print ( 'Horizontal Append:' , np . hstack (( np_list_one , np_list_two ))) [ 5 7 9 ] Horizontal Append: [ 1 2 3 4 5 6 ] ## Vertical Stack print ( 'Vertical Append:' , np . vstack (( np_list_one , np_list_two ))) Vertical Append: [[ 1 2 3 ] [ 4 5 6 ]] Generating Random Numbers # Generate a random float number random_float = np . random . random () random_float 0 .018929887384753874 # Generate a random float number random_floats = np . random . random ( 5 ) random_floats array ([ 0 .26392192, 0 .35842215, 0 .87908478, 0 .41902195, 0 .78926418 ]) # Generating a random integers between 0 and 10 random_int = np . random . randint ( 0 , 11 ) random_int 4 # Generating a random integers between 2 and 11, and creating a one row array random_int = np . random . randint ( 2 , 10 , size = 4 ) random_int array ([ 8 , 8 , 8 , 2 ]) # Generating a random integers between 0 and 10 random_int = np . random . randint ( 2 , 10 , size = ( 3 , 3 )) random_int array ([[ 3 , 5 , 3 ] , [ 7 , 3 , 6 ] , [ 2 , 3 , 3 ]]) Generationg random numbers # np.random.normal(mu, sigma, size) normal_array = np . random . normal ( 79 , 15 , 80 ) normal_array array ([ 89 .49990595, 82 .06056961, 107 .21445842, 38 .69307086, 47 .85259157, 93 .07381061, 76 .40724259, 78 .55675184, 72 .17358173, 47 .9888899 , 65 .10370622, 76 .29696568, 95 .58234254, 68 .14897213, 38 .75862686, 122 .5587927 , 67 .0762565 , 95 .73990864, 81 .97454563, 92 .54264805, 59 .37035153, 77 .76828101, 52 .30752166, 64 .43109931, 62 .63695351, 90 .04616138, 75 .70009094, 49 .87586877, 80 .22002414, 68 .56708848, 76 .27791052, 67 .24343975, 81 .86363935, 78 .22703433, 102 .85737041, 65 .15700341, 84 .87033426, 76 .7569997 , 64 .61321853, 67 .37244562, 74 .4068773 , 58 .65119655, 71 .66488727, 53 .42458179, 70 .26872028, 60 .96588544, 83 .56129414, 72 .14255326, 81 .00787609, 71 .81264853, 72 .64168853, 86 .56608717, 94 .94667321, 82 .32676973, 70 .5165446 , 85 .43061003, 72 .45526212, 87 .34681775, 87 .69911217, 103 .02831489, 75 .28598596, 67 .17806893, 92 .41274447, 101 .06662611, 87 .70013935, 70 .73980645, 46 .40368207, 50 .17947092, 61 .75618542, 90 .26191397, 78 .63968639, 70 .84550744, 88 .91826581, 103 .91474733, 66 .3064638 , 79 .49726264, 70 .81087439, 83 .90130623, 87 .58555972, 59 .95462521 ]) Numpy and Statistics import matplotlib.pyplot as plt import seaborn as sns sns . set () plt . hist ( normal_array , color = \"grey\" , bins = 50 ) ( array ([ 2 ., 0 ., 0 ., 0 ., 1 ., 2 ., 2 ., 0 ., 2 ., 0 ., 0 ., 1 ., 2 ., 2 ., 1 ., 4 ., 3 ., 4 ., 2 ., 7 ., 2 ., 2 ., 5 ., 4 ., 2 ., 4 ., 3 ., 2 ., 1 ., 5 ., 3 ., 0 ., 3 ., 2 ., 1 ., 0 ., 0 ., 1 ., 3 ., 0 ., 1 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 1 . ]) , array ([ 38 .69307086, 40 .37038529, 42 .04769973, 43 .72501417, 45 .4023286 , 47 .07964304, 48 .75695748, 50 .43427191, 52 .11158635, 53 .78890079, 55 .46621523, 57 .14352966, 58 .8208441 , 60 .49815854, 62 .17547297, 63 .85278741, 65 .53010185, 67 .20741628, 68 .88473072, 70 .56204516, 72 .23935959, 73 .91667403, 75 .59398847, 77 .27130291, 78 .94861734, 80 .62593178, 82 .30324622, 83 .98056065, 85 .65787509, 87 .33518953, 89 .01250396, 90 .6898184 , 92 .36713284, 94 .04444727, 95 .72176171, 97 .39907615, 99 .07639058, 100 .75370502, 102 .43101946, 104 .1083339 , 105 .78564833, 107 .46296277, 109 .14027721, 110 .81759164, 112 .49490608, 114 .17222052, 115 .84953495, 117 .52684939, 119 .20416383, 120 .88147826, 122 .5587927 ]) , <a list of 50 Patch objects> ) Matrix in numpy four_by_four_matrix = np . matrix ( np . ones (( 4 , 4 ), dtype = float )) four_by_four_matrix matrix ([[ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ]]) np . asarray ( four_by_four_matrix )[ 2 ] = 2 four_by_four_matrix matrix ([[ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 2 ., 2 ., 2 ., 2 . ] , [ 1 ., 1 ., 1 ., 1 . ]]) Numpy numpy.arange() What is Arrange? Sometimes, you want to create values that are evenly spaced within a defined interval. For instance, you want to create values from 1 to 10; you can use numpy.arange() function # creating list using range(starting, stop, step) lst = range ( 0 , 11 , 2 ) lst range ( 0 , 11 , 2 ) for l in lst : print ( l ) ```sh 0 2 4 6 8 10 ```py # Similar to range arange numpy.arange(start, stop, step) whole_numbers = np.arange(0, 20, 1) whole_numbers array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 ]) natural_numbers = np . arange ( 1 , 20 , 1 ) natural_numbers odd_numbers = np . arange ( 1 , 20 , 2 ) odd_numbers array ([ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]) even_numbers = np . arange ( 2 , 20 , 2 ) even_numbers array ([ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 ]) Creating sequence of numbers using linspace # numpy.linspace() # numpy.logspace() in Python with Example # For instance, it can be used to create 10 values from 1 to 5 evenly spaced. np . linspace ( 1.0 , 5.0 , num = 10 ) array ([ 1 . , 1 .44444444, 1 .88888889, 2 .33333333, 2 .77777778, 3 .22222222, 3 .66666667, 4 .11111111, 4 .55555556, 5 . ]) # not to include the last value in the interval np . linspace ( 1.0 , 5.0 , num = 5 , endpoint = False ) array([1. , 1.8, 2.6, 3.4, 4.2]) # LogSpace # LogSpace returns even spaced numbers on a log scale. Logspace has the same parameters as np.linspace. # Syntax: # numpy.logspace(start, stop, num, endpoint) np . logspace ( 2 , 4.0 , num = 4 ) array ([ 100 . , 464 .15888336, 2154 .43469003, 10000 . ]) # to check the size of an array x = np . array ([ 1 , 2 , 3 ], dtype = np . complex128 ) x array ([ 1 .+0.j, 2 .+0.j, 3 .+0.j ]) x . itemsize 16 # indexing and Slicing NumPy Arrays in Python np_list = np . array ([( 1 , 2 , 3 ), ( 4 , 5 , 6 )]) np_list array ([[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ]]) print ( 'First row: ' , np_list [ 0 ]) print ( 'Second row: ' , np_list [ 1 ]) First row: [ 1 2 3 ] Second row: [ 4 5 6 ] print('First column: ', np_list[:,0]) print('Second column: ', np_list[:,1]) print('Third column: ', np_list[:,2]) First column: [ 1 4 ] Second column: [ 2 5 ] Third column: [ 3 6 ] NumPy Statistical Functions with Example NumPy has quite useful statistical functions for finding minimum, maximum, mean, median, percentile,standard deviation and variance, etc from the given elements in the array. The functions are explained as follows \u2212 Statistical function Numpy is equipped with the robust statistical function as listed below Numpy Functions Min np.min() Max np.max() Mean np.mean() Median np.median() Varience Percentile Standard deviation np.std() np_normal_dis = np . random . normal ( 5 , 0.5 , 100 ) np_normal_dis ## min, max, mean, median, sd print ( 'min: ' , two_dimension_array . min ()) print ( 'max: ' , two_dimension_array . max ()) print ( 'mean: ' , two_dimension_array . mean ()) # print('median: ', two_dimension_array.median()) print ( 'sd: ' , two_dimension_array . std ()) min: 1 max: 55 mean: 14.777777777777779 sd: 18.913709183069525 min : 1 max : 55 mean : 14.777777777777779 sd : 18.913709183069525 print ( two_dimension_array ) print ( 'Column with minimum: ' , np . amin ( two_dimension_array , axis = 0 )) print ( 'Column with maximum: ' , np . amax ( two_dimension_array , axis = 0 )) print ( '=== Row ==' ) print ( 'Row with minimum: ' , np . amin ( two_dimension_array , axis = 1 )) print ( 'Row with maximum: ' , np . amax ( two_dimension_array , axis = 1 )) [[ 1 2 3] [ 4 55 44] [ 7 8 9]] Column with minimum: [1 2 3] Column with maximum: [ 7 55 44] === Row == Row with minimum: [1 4 7] Row with maximum: [ 3 55 9] How to create repeating sequences? a = [ 1 , 2 , 3 ] # Repeat whole of 'a' two times print ( 'Tile: ' , np . tile ( a , 2 )) # Repeat each element of 'a' two times print ( 'Repeat: ' , np . repeat ( a , 2 )) Tile: [1 2 3 1 2 3] Repeat: [1 1 2 2 3 3] How to generate random numbers? # One random number between [0,1) one_random_num = np . random . random () one_random_in = np . random print ( one_random_num ) 0.6149403282678213 0.4763968133790438 0.4763968133790438 # Random numbers between [0,1) of shape 2,3 r = np . random . random ( size = [ 2 , 3 ]) print ( r ) [[0.13031737 0.4429537 0.1129527 ] [0.76811539 0.88256594 0.6754075 ]] print ( np . random . choice ([ 'a' , 'e' , 'i' , 'o' , 'u' ], size = 10 )) ['u' 'o' 'o' 'i' 'e' 'e' 'u' 'o' 'u' 'a'] [ 'i' 'u' 'e' 'o' 'a' 'i' 'e' 'u' 'o' 'i' ] ['iueoaieuoi'] ## Random numbers between [0, 1] of shape 2, 2 rand = np . random . rand ( 2 , 2 ) rand array([[0.97992598, 0.79642484], [0.65263629, 0.55763145]]) rand2 = np . random . randn ( 2 , 2 ) rand2 array([[ 1.65593322, -0.52326621], [ 0.39071179, -2.03649407]]) # Random integers between [0, 10) of shape 2,5 rand_int = np . random . randint ( 0 , 10 , size = [ 5 , 3 ]) rand_int array([[0, 7, 5], [4, 1, 4], [3, 5, 3], [4, 3, 8], [4, 6, 7]]) from scipy import stats np_normal_dis = np . random . normal ( 5 , 0.5 , 1000 ) # mean, standard deviation, number of samples np_normal_dis ## min, max, mean, median, sd print ( 'min: ' , np . min ( np_normal_dis )) print ( 'max: ' , np . max ( np_normal_dis )) print ( 'mean: ' , np . mean ( np_normal_dis )) print ( 'median: ' , np . median ( np_normal_dis )) print ( 'mode: ' , stats . mode ( np_normal_dis )) print ( 'sd: ' , np . std ( np_normal_dis )) min: 3 .557811005458804 max: 6 .876317743643499 mean: 5 .035832048106663 median: 5 .020161980441937 mode: ModeResult ( mode = array ([ 3 .55781101 ]) , count = array ([ 1 ])) sd: 0 .489682424165213 plt . hist ( np_normal_dis , color = \"grey\" , bins = 21 ) plt . show () # numpy.dot(): Dot Product in Python using Numpy # Dot Product # Numpy is powerful library for matrices computation. For instance, you can compute the dot product with np.dot # Syntax # numpy.dot(x, y, out=None) Linear Algebra Dot Product ## Linear algebra ### Dot product: product of two arrays f = np . array ([ 1 , 2 , 3 ]) g = np . array ([ 4 , 5 , 3 ]) ### 1*4+2*5 + 3*6 np . dot ( f , g ) # 23 NumPy Matrix Multiplication with np.matmul() ### Matmul: matruc product of two arrays h = [[ 1 , 2 ],[ 3 , 4 ]] i = [[ 5 , 6 ],[ 7 , 8 ]] ### 1*5+2*7 = 19 np . matmul ( h , i ) array ([[ 19 , 22 ] , [ 43 , 50 ]]) ## Determinant 2*2 matrix ### 5*8-7*6np.linalg.det(i) np . linalg . det ( i ) -1.999999999999999 Z = np . zeros (( 8 , 8 )) Z [ 1 :: 2 ,:: 2 ] = 1 Z [:: 2 , 1 :: 2 ] = 1 Z array([[0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.]]) new_list = [ x + 2 for x in range ( 0 , 11 )] new_list [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] np_arr = np . array ( range ( 0 , 11 )) np_arr + 2 array([ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) We use linear equation for quatities which have linear relationship. Let's see the example below: temp = np . array ([ 1 , 2 , 3 , 4 , 5 ]) pressure = temp * 2 + 5 pressure array([ 7, 9, 11, 13, 15]) plt . plot ( temp , pressure ) plt . xlabel ( 'Temperature in oC' ) plt . ylabel ( 'Pressure in atm' ) plt . title ( 'Temperature vs Pressure' ) plt . xticks ( np . arange ( 0 , 6 , step = 0.5 )) plt . show () To draw the Gaussian normal distribution using numpy. As you can see below, the numpy can generate random numbers. To create random sample, we need the mean(mu), sigma(standard deviation), mumber of data points. mu = 28 sigma = 15 samples = 100000 x = np . random . normal ( mu , sigma , samples ) ax = sns . distplot ( x ); ax . set ( xlabel = \"x\" , ylabel = 'y' ) plt . show () \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"Numpy"},{"location":"numpy/#statistics","text":"Statistics is the discipline that studies the collection , organization , displaying , analysis , interpretation and presentation of data. Statistics is a branch of mathematics that is recommended to be a prerequisite for data science and machine learning. Statistics is a very broad field but we will focus in this section only on the most relevant part. After completing this challenge, you may go to web development, data analysis, machine learning and data science path. Whatever path you may follow, at some point in your career you will get data which you may work on. Having some statistical knowledge will help you to make decision based on data, data tells as they say .","title":"Statistics"},{"location":"numpy/#data","text":"What is data? Data is any set of characters that is gathered and translated for some purpose, usually analysis. It can be any character, including text and numbers, pictures, sound, or video. If data is not put into context, it doesn't give any sense to a human or computer. To make sense from data we need to work on the data using different tools. The work flow of data analysis, data science or machine learning starts from data. Data can be provided from some data source or it can be created. There are structured and and unstructure data. Data can be found as small or big data format. Most of the data types we will get have been covered in the file handling section.","title":"Data"},{"location":"numpy/#statistics-module","text":"The python statistics module provides functions for calculating mathematical statistics of numeric data. The module is not intended to be a competitor to third-party libraries such as NumPy, SciPy, or proprietary full-featured statistics packages aimed at professional statisticians such as Minitab, SAS and Matlab. It is aimed at the level of graphing and scientific calculators.","title":"Statistics Module"},{"location":"numpy/#numpy","text":"In the first section we defined python as a great general-purpose programming language on its own, but with the help of other popular libraries (numpy, scipy, matplotlib, pandas etc) it becomes a powerful environment for scientific computing. Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with arrays. So far, we have been using vscode but from now on I would recommend using Jupyter Notebook. To access jupter notebook let's install anaconda . If you are using anaconda most of the common packages are included and you don't have install packages if you installed anaconda. asabeneh@Asabeneh:~/Desktop/30DaysOfPython$ pip install numpy","title":"NumPy"},{"location":"numpy/#importing-numpy","text":"Jupyter notebook is available if your are in favor of jupyter notebook # How to import numpy import numpy as np # How to check the version of the numpy package print ( 'numpy:' , np . __version__ ) # Checking the available methods print ( dir ( np ))","title":"Importing NumPy"},{"location":"numpy/#creating-numpy-array-using","text":"","title":"Creating numpy array using"},{"location":"numpy/#creating-int-numpy-arrays","text":"# Creating python List python_list = [ 1 , 2 , 3 , 4 , 5 ] # Checking data types print ( 'Type:' , type ( python_list )) # <class 'list'> # print ( python_list ) # [1, 2, 3, 4, 5] two_dimensional_list = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]] print ( two_dimensional_list ) # [[0, 1, 2], [3, 4, 5], [6, 7, 8]] # Creating Numpy(Numerical Python) array from python list numpy_array_from_list = np . array ( python_list ) print ( type ( numpy_array_from_list )) # <class 'numpy.ndarray'> print ( numpy_array_from_list ) # array([1, 2, 3, 4, 5])","title":"Creating int numpy arrays"},{"location":"numpy/#creating-float-numpy-arrays","text":"Creating a float numpy array from list with a float data type parameter # Python list python_list = [ 1 , 2 , 3 , 4 , 5 ] numy_array_from_list2 = np . array ( python_list , dtype = float ) print ( numy_array_from_list2 ) # array([1., 2., 3., 4., 5.])","title":"Creating float numpy arrays"},{"location":"numpy/#creating-boolean-numpy-arrays","text":"Creating a boolean a numpy array from list numpy_bool_array = np . array ([ 0 , 1 , - 1 , 0 , 0 ], dtype = bool ) print ( numpy_bool_array ) # array([False, True, True, False, False])","title":"Creating boolean numpy arrays"},{"location":"numpy/#creating-multidimensional-array-using-numpy","text":"A numpy array may have one or multiple rows and columns two_dimensional_list = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]] numpy_two_dimensional_list = np . array ( two_dimensional_list ) print ( type ( numpy_two_dimensional_list )) print ( numpy_two_dimensional_list ) <class 'numpy.ndarray' > [[ 0 1 2 ] [ 3 4 5 ] [ 6 7 8 ]]","title":"Creating multidimensional array using numpy"},{"location":"numpy/#converting-numpy-array-to-list","text":"# We can always convert an array back to a python list using tolist(). np_to_list = numpy_array_from_list . tolist () print ( type ( np_to_list )) print ( 'one dimensional array:' , np_to_list ) print ( 'two dimensional array: ' , numpy_two_dimensional_list . tolist ()) <class 'list' > one dimensional array: [ 1 , 2 , 3 , 4 , 5 ] two dimensional array: [[ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ]]","title":"Converting numpy array to list"},{"location":"numpy/#creating-numpy-array-from-tuple","text":"# Numpy array from tuple # Creating tuple in Python python_tuple = ( 1 , 2 , 3 , 4 , 5 ) print ( type ( python_tuple )) # <class 'tuple'> print ( 'python_tuple: ' , python_tuple ) # python_tuple: (1, 2, 3, 4, 5) numpy_array_from_tuple = np . array ( python_tuple ) print ( type ( numpy_array_from_tuple )) # <class 'numpy.ndarray'> print ( 'numpy_array_from_tuple: ' , numpy_array_from_tuple ) # numpy_array_from_tuple: [1 2 3 4 5]","title":"Creating numpy array from tuple"},{"location":"numpy/#shape-of-numpy-array","text":"The shape method provide the shape of the array as a tuple. The first is the row and the second is the column. If the array is just one dimensional it returns the size of the array. nums = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( nums ) print ( 'shape of nums: ' , nums . shape ) print ( numpy_two_dimensional_list ) print ( 'shape of numpy_two_dimensional_list: ' , numpy_two_dimensional_list . shape ) three_by_four_array = np . array ([[ 0 , 1 , 2 , 3 ], [ 4 , 5 , 6 , 7 ], [ 8 , 9 , 10 , 11 ]]) print ( three_by_four_array . shape ) [ 1 2 3 4 5 ] shape of nums: ( 5 , ) [[ 0 1 2 ] [ 3 4 5 ] [ 6 7 8 ]] shape of numpy_two_dimensional_list: ( 3 , 3 ) ( 3 , 4 )","title":"Shape of numpy array"},{"location":"numpy/#data-type-of-numpy-array","text":"Type of data types: str, int, float, complex, bool, list, None int_lists = [ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ] int_array = np . array ( int_lists ) float_array = np . array ( int_lists , dtype = float ) print ( int_array ) print ( int_array . dtype ) print ( float_array ) print ( float_array . dtype ) [ -3 -2 -1 0 1 2 3 ] int64 [ -3. -2. -1. 0 . 1 . 2 . 3 . ] float64","title":"Data type of numpy array"},{"location":"numpy/#size-of-a-numpy-array","text":"In numpy to know the number of items in a numpy array list we use size numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) two_dimensional_list = np . array ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]]) print ( 'The size:' , numpy_array_from_list . size ) # 5 print ( 'The size:' , two_dimensional_list . size ) # 3 The size: 5 The size: 9","title":"Size of a numpy array"},{"location":"numpy/#mathematical-operation-using-numpy","text":"Numpy array is not like exactly like python list. To do mathematical operation in pyhton list we have to loop through the items but numpy can allow to do any mathematical operation without looping. Mathematical Operation: Addition (+) Subtraction (-) Multiplication (*) Division (/) Modules (%) Floor Division(//) Exponential(**)","title":"Mathematical Operation using numpy"},{"location":"numpy/#addition","text":"# Mathematical Operation # Addition numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_plus_original = numpy_array_from_list + 10 print ( ten_plus_original ) original array: [ 1 2 3 4 5 ] [ 11 12 13 14 15 ]","title":"Addition"},{"location":"numpy/#subtraction","text":"# Subtraction numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_minus_original = numpy_array_from_list - 10 print ( ten_minus_original ) original array: [ 1 2 3 4 5 ] [ -9 -8 -7 -6 -5 ]","title":"Subtraction"},{"location":"numpy/#multiplication","text":"# Multiplication numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list * 10 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 10 20 30 40 50 ]","title":"Multiplication"},{"location":"numpy/#division","text":"# Division numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list / 10 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 0 .1 0 .2 0 .3 0 .4 0 .5 ]","title":"Division"},{"location":"numpy/#modulus","text":"# Modulus; Finding the remainder numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list % 3 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 1 2 0 1 2 ]","title":"Modulus"},{"location":"numpy/#floor-division","text":"# Floor division: the division result without the remainder numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list // 10 print ( ten_times_original )","title":"Floor Division"},{"location":"numpy/#exponential","text":"# Exponential is finding some number the power of another: numpy_array_from_list = np . array ([ 1 , 2 , 3 , 4 , 5 ]) print ( 'original array: ' , numpy_array_from_list ) ten_times_original = numpy_array_from_list ** 2 print ( ten_times_original ) original array: [ 1 2 3 4 5 ] [ 1 4 9 16 25 ]","title":"Exponential"},{"location":"numpy/#checking-data-types","text":"#Int, Float numbers numpy_int_arr = np . array ([ 1 , 2 , 3 , 4 ]) numpy_float_arr = np . array ([ 1.1 , 2.0 , 3.2 ]) numpy_bool_arr = np . array ([ - 3 , - 2 , 0 , 1 , 2 , 3 ], dtype = 'bool' ) print ( numpy_int_arr . dtype ) print ( numpy_float_arr . dtype ) print ( numpy_bool_arr . dtype ) int64 float64 bool","title":"Checking data types"},{"location":"numpy/#converting-types","text":"We can convert the data types of numpy array Int to Float numpy_int_arr = np . array ([ 1 , 2 , 3 , 4 ], dtype = 'float' ) numpy_int_arr array([1., 2., 3., 4.]) Float to Int numpy_int_arr = np . array ([ 1. , 2. , 3. , 4. ], dtype = 'int' ) numpy_int_arr array ([ 1 , 2 , 3 , 4 ]) Int ot boolean np . array ([ - 3 , - 2 , 0 , 1 , 2 , 3 ], dtype = 'bool' ) array ([ True, True, False, True, True, True ]) Int to str numpy_float_list . astype ( 'int' ) . astype ( 'str' ) array ([ '1' , '2' , '3' ] , dtype = '<U21' )","title":"Converting types"},{"location":"numpy/#multi-dimensional-arrays","text":"# 2 Dimension Array two_dimension_array = np . array ([( 1 , 2 , 3 ),( 4 , 5 , 6 ), ( 7 , 8 , 9 )]) print ( type ( two_dimension_array )) print ( two_dimension_array ) print ( 'Shape: ' , two_dimension_array . shape ) print ( 'Size:' , two_dimension_array . size ) print ( 'Data type:' , two_dimension_array . dtype ) <class 'numpy.ndarray' > [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]] Shape: ( 3 , 3 ) Size: 9 Data type: int64","title":"Multi-dimensional Arrays"},{"location":"numpy/#getting-items-from-a-numpy-array","text":"# 2 Dimension Array two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) first_row = two_dimension_array [ 0 ] second_row = two_dimension_array [ 1 ] third_row = two_dimension_array [ 2 ] print ( 'First row:' , first_row ) print ( 'Second row:' , second_row ) print ( 'Third row: ' , third_row ) First row: [ 1 2 3 ] Second row: [ 4 5 6 ] Third row: [ 7 8 9 ] first_column = two_dimension_array [:, 0 ] second_column = two_dimension_array [:, 1 ] third_column = two_dimension_array [:, 2 ] print ( 'First column:' , first_column ) print ( 'Second column:' , second_column ) print ( 'Third column: ' , third_column ) print ( two_dimension_array ) First column: [ 1 4 7 ] Second column: [ 2 5 8 ] Third column: [ 3 6 9 ] [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]]","title":"Getting items from a numpy array"},{"location":"numpy/#slicing-numpy-array","text":"Slicing in numpy is similar to slicing in python list two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) first_two_rows_and_columns = two_dimension_array [ 0 : 2 , 0 : 2 ] print ( first_two_rows_and_columns ) [[ 1 2 ] [ 4 5 ]]","title":"Slicing Numpy array"},{"location":"numpy/#how-to-reverse-the-rows-and-the-whole-array","text":"two_dimension_array [::] array ([[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ]])","title":"How to reverse the rows and the whole array?"},{"location":"numpy/#reverse-the-row-and-column-positions","text":"two_dimension_array = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 , 8 , 9 ]]) two_dimension_array [:: - 1 ,:: - 1 ] array ([[ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] , [ 3 , 2 , 1 ]])","title":"Reverse the row and column positions"},{"location":"numpy/#how-to-represent-missing-values","text":"print ( two_dimension_array ) two_dimension_array [ 1 , 1 ] = 55 two_dimension_array [ 1 , 2 ] = 44 print ( two_dimension_array ) [[ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]] [[ 1 2 3 ] [ 4 55 44 ] [ 7 8 9 ]] # Numpy Zeroes # numpy.zeros(shape, dtype=float, order='C') numpy_zeroes = np . zeros (( 3 , 3 ), dtype = int , order = 'C' ) numpy_zeroes array ([[ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ]]) # Numpy Zeroes numpy_ones = np . ones (( 3 , 3 ), dtype = int , order = 'C' ) print ( numpy_ones ) [[ 1 1 1 ] [ 1 1 1 ] [ 1 1 1 ]] twoes = numpy_ones * 2 # Reshape # numpy.reshape(), numpy.flatten() first_shape = np . array ([( 1 , 2 , 3 ), ( 4 , 5 , 6 )]) print ( first_shape ) reshaped = first_shape . reshape ( 3 , 2 ) print ( reshaped ) [[ 1 2 3 ] [ 4 5 6 ]] [[ 1 2 ] [ 3 4 ] [ 5 6 ]] flattened = reshaped . flatten () flattened array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) ## Horitzontal Stack np_list_one = np . array ([ 1 , 2 , 3 ]) np_list_two = np . array ([ 4 , 5 , 6 ]) print ( np_list_one + np_list_two ) print ( 'Horizontal Append:' , np . hstack (( np_list_one , np_list_two ))) [ 5 7 9 ] Horizontal Append: [ 1 2 3 4 5 6 ] ## Vertical Stack print ( 'Vertical Append:' , np . vstack (( np_list_one , np_list_two ))) Vertical Append: [[ 1 2 3 ] [ 4 5 6 ]]","title":"How to represent missing values ?"},{"location":"numpy/#generating-random-numbers","text":"# Generate a random float number random_float = np . random . random () random_float 0 .018929887384753874 # Generate a random float number random_floats = np . random . random ( 5 ) random_floats array ([ 0 .26392192, 0 .35842215, 0 .87908478, 0 .41902195, 0 .78926418 ]) # Generating a random integers between 0 and 10 random_int = np . random . randint ( 0 , 11 ) random_int 4 # Generating a random integers between 2 and 11, and creating a one row array random_int = np . random . randint ( 2 , 10 , size = 4 ) random_int array ([ 8 , 8 , 8 , 2 ]) # Generating a random integers between 0 and 10 random_int = np . random . randint ( 2 , 10 , size = ( 3 , 3 )) random_int array ([[ 3 , 5 , 3 ] , [ 7 , 3 , 6 ] , [ 2 , 3 , 3 ]])","title":"Generating Random Numbers"},{"location":"numpy/#generationg-random-numbers","text":"# np.random.normal(mu, sigma, size) normal_array = np . random . normal ( 79 , 15 , 80 ) normal_array array ([ 89 .49990595, 82 .06056961, 107 .21445842, 38 .69307086, 47 .85259157, 93 .07381061, 76 .40724259, 78 .55675184, 72 .17358173, 47 .9888899 , 65 .10370622, 76 .29696568, 95 .58234254, 68 .14897213, 38 .75862686, 122 .5587927 , 67 .0762565 , 95 .73990864, 81 .97454563, 92 .54264805, 59 .37035153, 77 .76828101, 52 .30752166, 64 .43109931, 62 .63695351, 90 .04616138, 75 .70009094, 49 .87586877, 80 .22002414, 68 .56708848, 76 .27791052, 67 .24343975, 81 .86363935, 78 .22703433, 102 .85737041, 65 .15700341, 84 .87033426, 76 .7569997 , 64 .61321853, 67 .37244562, 74 .4068773 , 58 .65119655, 71 .66488727, 53 .42458179, 70 .26872028, 60 .96588544, 83 .56129414, 72 .14255326, 81 .00787609, 71 .81264853, 72 .64168853, 86 .56608717, 94 .94667321, 82 .32676973, 70 .5165446 , 85 .43061003, 72 .45526212, 87 .34681775, 87 .69911217, 103 .02831489, 75 .28598596, 67 .17806893, 92 .41274447, 101 .06662611, 87 .70013935, 70 .73980645, 46 .40368207, 50 .17947092, 61 .75618542, 90 .26191397, 78 .63968639, 70 .84550744, 88 .91826581, 103 .91474733, 66 .3064638 , 79 .49726264, 70 .81087439, 83 .90130623, 87 .58555972, 59 .95462521 ])","title":"Generationg random numbers"},{"location":"numpy/#numpy-and-statistics","text":"import matplotlib.pyplot as plt import seaborn as sns sns . set () plt . hist ( normal_array , color = \"grey\" , bins = 50 ) ( array ([ 2 ., 0 ., 0 ., 0 ., 1 ., 2 ., 2 ., 0 ., 2 ., 0 ., 0 ., 1 ., 2 ., 2 ., 1 ., 4 ., 3 ., 4 ., 2 ., 7 ., 2 ., 2 ., 5 ., 4 ., 2 ., 4 ., 3 ., 2 ., 1 ., 5 ., 3 ., 0 ., 3 ., 2 ., 1 ., 0 ., 0 ., 1 ., 3 ., 0 ., 1 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 0 ., 1 . ]) , array ([ 38 .69307086, 40 .37038529, 42 .04769973, 43 .72501417, 45 .4023286 , 47 .07964304, 48 .75695748, 50 .43427191, 52 .11158635, 53 .78890079, 55 .46621523, 57 .14352966, 58 .8208441 , 60 .49815854, 62 .17547297, 63 .85278741, 65 .53010185, 67 .20741628, 68 .88473072, 70 .56204516, 72 .23935959, 73 .91667403, 75 .59398847, 77 .27130291, 78 .94861734, 80 .62593178, 82 .30324622, 83 .98056065, 85 .65787509, 87 .33518953, 89 .01250396, 90 .6898184 , 92 .36713284, 94 .04444727, 95 .72176171, 97 .39907615, 99 .07639058, 100 .75370502, 102 .43101946, 104 .1083339 , 105 .78564833, 107 .46296277, 109 .14027721, 110 .81759164, 112 .49490608, 114 .17222052, 115 .84953495, 117 .52684939, 119 .20416383, 120 .88147826, 122 .5587927 ]) , <a list of 50 Patch objects> )","title":"Numpy and Statistics"},{"location":"numpy/#matrix-in-numpy","text":"four_by_four_matrix = np . matrix ( np . ones (( 4 , 4 ), dtype = float )) four_by_four_matrix matrix ([[ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ]]) np . asarray ( four_by_four_matrix )[ 2 ] = 2 four_by_four_matrix matrix ([[ 1 ., 1 ., 1 ., 1 . ] , [ 1 ., 1 ., 1 ., 1 . ] , [ 2 ., 2 ., 2 ., 2 . ] , [ 1 ., 1 ., 1 ., 1 . ]])","title":"Matrix in numpy"},{"location":"numpy/#numpy-numpyarange","text":"","title":"Numpy numpy.arange()"},{"location":"numpy/#what-is-arrange","text":"Sometimes, you want to create values that are evenly spaced within a defined interval. For instance, you want to create values from 1 to 10; you can use numpy.arange() function # creating list using range(starting, stop, step) lst = range ( 0 , 11 , 2 ) lst range ( 0 , 11 , 2 ) for l in lst : print ( l ) ```sh 0 2 4 6 8 10 ```py # Similar to range arange numpy.arange(start, stop, step) whole_numbers = np.arange(0, 20, 1) whole_numbers array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 ]) natural_numbers = np . arange ( 1 , 20 , 1 ) natural_numbers odd_numbers = np . arange ( 1 , 20 , 2 ) odd_numbers array ([ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]) even_numbers = np . arange ( 2 , 20 , 2 ) even_numbers array ([ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 ])","title":"What is Arrange?"},{"location":"numpy/#creating-sequence-of-numbers-using-linspace","text":"# numpy.linspace() # numpy.logspace() in Python with Example # For instance, it can be used to create 10 values from 1 to 5 evenly spaced. np . linspace ( 1.0 , 5.0 , num = 10 ) array ([ 1 . , 1 .44444444, 1 .88888889, 2 .33333333, 2 .77777778, 3 .22222222, 3 .66666667, 4 .11111111, 4 .55555556, 5 . ]) # not to include the last value in the interval np . linspace ( 1.0 , 5.0 , num = 5 , endpoint = False ) array([1. , 1.8, 2.6, 3.4, 4.2]) # LogSpace # LogSpace returns even spaced numbers on a log scale. Logspace has the same parameters as np.linspace. # Syntax: # numpy.logspace(start, stop, num, endpoint) np . logspace ( 2 , 4.0 , num = 4 ) array ([ 100 . , 464 .15888336, 2154 .43469003, 10000 . ]) # to check the size of an array x = np . array ([ 1 , 2 , 3 ], dtype = np . complex128 ) x array ([ 1 .+0.j, 2 .+0.j, 3 .+0.j ]) x . itemsize 16 # indexing and Slicing NumPy Arrays in Python np_list = np . array ([( 1 , 2 , 3 ), ( 4 , 5 , 6 )]) np_list array ([[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ]]) print ( 'First row: ' , np_list [ 0 ]) print ( 'Second row: ' , np_list [ 1 ]) First row: [ 1 2 3 ] Second row: [ 4 5 6 ] print('First column: ', np_list[:,0]) print('Second column: ', np_list[:,1]) print('Third column: ', np_list[:,2]) First column: [ 1 4 ] Second column: [ 2 5 ] Third column: [ 3 6 ]","title":"Creating sequence of numbers using linspace"},{"location":"numpy/#numpy-statistical-functions-with-example","text":"NumPy has quite useful statistical functions for finding minimum, maximum, mean, median, percentile,standard deviation and variance, etc from the given elements in the array. The functions are explained as follows \u2212 Statistical function Numpy is equipped with the robust statistical function as listed below Numpy Functions Min np.min() Max np.max() Mean np.mean() Median np.median() Varience Percentile Standard deviation np.std() np_normal_dis = np . random . normal ( 5 , 0.5 , 100 ) np_normal_dis ## min, max, mean, median, sd print ( 'min: ' , two_dimension_array . min ()) print ( 'max: ' , two_dimension_array . max ()) print ( 'mean: ' , two_dimension_array . mean ()) # print('median: ', two_dimension_array.median()) print ( 'sd: ' , two_dimension_array . std ()) min: 1 max: 55 mean: 14.777777777777779 sd: 18.913709183069525 min : 1 max : 55 mean : 14.777777777777779 sd : 18.913709183069525 print ( two_dimension_array ) print ( 'Column with minimum: ' , np . amin ( two_dimension_array , axis = 0 )) print ( 'Column with maximum: ' , np . amax ( two_dimension_array , axis = 0 )) print ( '=== Row ==' ) print ( 'Row with minimum: ' , np . amin ( two_dimension_array , axis = 1 )) print ( 'Row with maximum: ' , np . amax ( two_dimension_array , axis = 1 )) [[ 1 2 3] [ 4 55 44] [ 7 8 9]] Column with minimum: [1 2 3] Column with maximum: [ 7 55 44] === Row == Row with minimum: [1 4 7] Row with maximum: [ 3 55 9]","title":"NumPy Statistical Functions with Example"},{"location":"numpy/#how-to-create-repeating-sequences","text":"a = [ 1 , 2 , 3 ] # Repeat whole of 'a' two times print ( 'Tile: ' , np . tile ( a , 2 )) # Repeat each element of 'a' two times print ( 'Repeat: ' , np . repeat ( a , 2 )) Tile: [1 2 3 1 2 3] Repeat: [1 1 2 2 3 3]","title":"How to create repeating sequences?"},{"location":"numpy/#how-to-generate-random-numbers","text":"# One random number between [0,1) one_random_num = np . random . random () one_random_in = np . random print ( one_random_num ) 0.6149403282678213 0.4763968133790438 0.4763968133790438 # Random numbers between [0,1) of shape 2,3 r = np . random . random ( size = [ 2 , 3 ]) print ( r ) [[0.13031737 0.4429537 0.1129527 ] [0.76811539 0.88256594 0.6754075 ]] print ( np . random . choice ([ 'a' , 'e' , 'i' , 'o' , 'u' ], size = 10 )) ['u' 'o' 'o' 'i' 'e' 'e' 'u' 'o' 'u' 'a'] [ 'i' 'u' 'e' 'o' 'a' 'i' 'e' 'u' 'o' 'i' ] ['iueoaieuoi'] ## Random numbers between [0, 1] of shape 2, 2 rand = np . random . rand ( 2 , 2 ) rand array([[0.97992598, 0.79642484], [0.65263629, 0.55763145]]) rand2 = np . random . randn ( 2 , 2 ) rand2 array([[ 1.65593322, -0.52326621], [ 0.39071179, -2.03649407]]) # Random integers between [0, 10) of shape 2,5 rand_int = np . random . randint ( 0 , 10 , size = [ 5 , 3 ]) rand_int array([[0, 7, 5], [4, 1, 4], [3, 5, 3], [4, 3, 8], [4, 6, 7]]) from scipy import stats np_normal_dis = np . random . normal ( 5 , 0.5 , 1000 ) # mean, standard deviation, number of samples np_normal_dis ## min, max, mean, median, sd print ( 'min: ' , np . min ( np_normal_dis )) print ( 'max: ' , np . max ( np_normal_dis )) print ( 'mean: ' , np . mean ( np_normal_dis )) print ( 'median: ' , np . median ( np_normal_dis )) print ( 'mode: ' , stats . mode ( np_normal_dis )) print ( 'sd: ' , np . std ( np_normal_dis )) min: 3 .557811005458804 max: 6 .876317743643499 mean: 5 .035832048106663 median: 5 .020161980441937 mode: ModeResult ( mode = array ([ 3 .55781101 ]) , count = array ([ 1 ])) sd: 0 .489682424165213 plt . hist ( np_normal_dis , color = \"grey\" , bins = 21 ) plt . show () # numpy.dot(): Dot Product in Python using Numpy # Dot Product # Numpy is powerful library for matrices computation. For instance, you can compute the dot product with np.dot # Syntax # numpy.dot(x, y, out=None)","title":"How to generate random numbers?"},{"location":"numpy/#linear-algebra","text":"Dot Product ## Linear algebra ### Dot product: product of two arrays f = np . array ([ 1 , 2 , 3 ]) g = np . array ([ 4 , 5 , 3 ]) ### 1*4+2*5 + 3*6 np . dot ( f , g ) # 23","title":"Linear Algebra"},{"location":"numpy/#numpy-matrix-multiplication-with-npmatmul","text":"### Matmul: matruc product of two arrays h = [[ 1 , 2 ],[ 3 , 4 ]] i = [[ 5 , 6 ],[ 7 , 8 ]] ### 1*5+2*7 = 19 np . matmul ( h , i ) array ([[ 19 , 22 ] , [ 43 , 50 ]]) ## Determinant 2*2 matrix ### 5*8-7*6np.linalg.det(i) np . linalg . det ( i ) -1.999999999999999 Z = np . zeros (( 8 , 8 )) Z [ 1 :: 2 ,:: 2 ] = 1 Z [:: 2 , 1 :: 2 ] = 1 Z array([[0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.], [0., 1., 0., 1., 0., 1., 0., 1.], [1., 0., 1., 0., 1., 0., 1., 0.]]) new_list = [ x + 2 for x in range ( 0 , 11 )] new_list [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] np_arr = np . array ( range ( 0 , 11 )) np_arr + 2 array([ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) We use linear equation for quatities which have linear relationship. Let's see the example below: temp = np . array ([ 1 , 2 , 3 , 4 , 5 ]) pressure = temp * 2 + 5 pressure array([ 7, 9, 11, 13, 15]) plt . plot ( temp , pressure ) plt . xlabel ( 'Temperature in oC' ) plt . ylabel ( 'Pressure in atm' ) plt . title ( 'Temperature vs Pressure' ) plt . xticks ( np . arange ( 0 , 6 , step = 0.5 )) plt . show () To draw the Gaussian normal distribution using numpy. As you can see below, the numpy can generate random numbers. To create random sample, we need the mean(mu), sigma(standard deviation), mumber of data points. mu = 28 sigma = 15 samples = 100000 x = np . random . normal ( mu , sigma , samples ) ax = sns . distplot ( x ); ax . set ( xlabel = \"x\" , ylabel = 'y' ) plt . show () \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"NumPy Matrix Multiplication with np.matmul()"},{"location":"pandas/","text":"Pandas is an open source, high-performance, easy-to-use data structures and data analysis tools for the Python programming language. Pandas adds data structures and tools designed to work with table-like data which is Series and Data Frames . Pandas provides tools for data manipulation: reshaping merging sorting slicing aggregation imputation. If you are using anaconda, you do not have install pandas. Installing Pandas For Mac: pip install conda conda install pandas For Windows: pip install conda pip install pandas Pandas data structure is based on Series and DataFrames . A series is a column and a DataFrame is a multidimensional table made up of collection of series . In order to create a pandas series we should use numpy to create a one dimensional arrays or a python list. Let us see an example of a series: Names Pandas Series Countries Series Cities Series As you can see, pandas series is just one column of data. If we want to have multiple columns we use data frames. The example below shows pandas DataFrames. Let us see, an example of a pandas data frame: Data frame is a collection of rows and columns. Look at the table below; it has many more columns than the example above: Next, we will see how to import pandas and how to create Series and DataFrames using pandas Importing Pandas import pandas as pd # importing pandas as pd import numpy as np # importing numpy as np Creating Pandas Series with Default Index nums = [ 1 , 2 , 3 , 4 , 5 ] s = pd . Series ( nums ) print ( s ) 0 1 1 2 2 3 3 4 4 5 dtype: int64 Creating Pandas Series with custom index nums = [ 1 , 2 , 3 , 4 , 5 ] s = pd . Series ( nums , index = [ 1 , 2 , 3 , 4 , 5 ]) print ( s ) 1 1 2 2 3 3 4 4 5 5 dtype: int64 fruits = [ 'Orange' , 'Banana' , 'Mango' ] fruits = pd . Series ( fruits , index = [ 1 , 2 , 3 ]) print ( fruits ) 1 Orange 2 Banana 3 Mango dtype: object Creating Pandas Series from a Dictionary dct = { 'name' : 'Asabeneh' , 'country' : 'Finland' , 'city' : 'Helsinki' } s = pd . Series ( dct ) print ( s ) name Asabeneh country Finland city Helsinki dtype: object Creating a Constant Pandas Series s = pd . Series ( 10 , index = [ 1 , 2 , 3 ]) print ( s ) 1 10 2 10 3 10 dtype: int64 Creating a Pandas Series Using Linspace s = pd . Series ( np . linspace ( 5 , 20 , 10 )) # linspace(starting, end, items) print ( s ) 0 5 .000000 1 6 .666667 2 8 .333333 3 10 .000000 4 11 .666667 5 13 .333333 6 15 .000000 7 16 .666667 8 18 .333333 9 20 .000000 dtype: float64 DataFrames Pandas data frames can be created in different ways. Creating DataFrames from List of Lists data = [ [ 'Medo' , 'Finland' , 'Helsink' ], [ 'Joe' , 'UK' , 'London' ], [ 'Sarah' , 'Sweden' , 'Stockholm' ] ] df = pd . DataFrame ( data , columns = [ 'Names' , 'Country' , 'City' ]) print ( df ) Names Country City 0 Asabeneh Finland Helsink 1 David UK London 2 John Sweden Stockholm Creating DataFrame Using Dictionary data = { 'Name' : [ 'Asabeneh' , 'David' , 'John' ], 'Country' :[ 'Finland' , 'UK' , 'Sweden' ], 'City' : [ 'Helsiki' , 'London' , 'Stockholm' ]} df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsiki 1 David UK London 2 John Sweden Stockholm Creating DataFrames from a List of Dictionaries data = [ { 'Name' : 'Asabeneh' , 'Country' : 'Finland' , 'City' : 'Helsinki' }, { 'Name' : 'David' , 'Country' : 'UK' , 'City' : 'London' }, { 'Name' : 'John' , 'Country' : 'Sweden' , 'City' : 'Stockholm' }] df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsinki 1 David UK London 2 John Sweden Stockholm Reading CSV File Using Pandas To download the CSV file, what is needed in this example, console/command line is enough: curl -O https://raw.githubusercontent.com/Asabeneh/30-Days-Of-Python/master/data/weight-height.csv Put the downloaded file in your working directory. import pandas as pd df = pd . read_csv ( 'weight-height.csv' ) print ( df ) Data Exploration Let us read only the first 5 rows using head() print ( df . head ()) # give five rows we can increase the number of rows by passing argument to the head() method Gender Height Weight 0 Male 73.847017 241.893563 1 Male 68.781904 162.310473 2 Male 74.110105 212.740856 3 Male 71.730978 220.042470 4 Male 69.881796 206.349801 Let us also explore the last recordings of the dataframe using the tail() methods. print ( df . tail ()) # tails give the last five rows, we can increase the rows by passing argument to tail method Gender Height Weight 9995 Female 66.172652 136.777454 9996 Female 67.067155 170.867906 9997 Female 63.867992 128.475319 9998 Female 69.034243 163.852461 9999 Female 61.944246 113.649103 As you can see the csv file has three rows: Gender, Height and Weight. If the DataFrame would have a long rows, it would be hard to know all the columns. Therefore, we should use a method to know the colums. we do not know the number of rows. Let's use shape meathod. print ( df . shape ) # as you can see 10000 rows and three columns (10000, 3) Let us get all the columns using columns. print ( df . columns ) Index(['Gender', 'Height', 'Weight'], dtype='object') Now, let us get a specific column using the column key heights = df [ 'Height' ] # this is now a series print ( heights ) 0 73 .847017 1 68 .781904 2 74 .110105 3 71 .730978 4 69 .881796 ... 9995 66 .172652 9996 67 .067155 9997 63 .867992 9998 69 .034243 9999 61 .944246 Name: Height, Length: 10000 , dtype: float64 weights = df [ 'Weight' ] # this is now a series print ( weights ) 0 241 .893563 1 162 .310473 2 212 .740856 3 220 .042470 4 206 .349801 ... 9995 136 .777454 9996 170 .867906 9997 128 .475319 9998 163 .852461 9999 113 .649103 Name: Weight, Length: 10000 , dtype: float64 print ( len ( heights ) == len ( weights )) True The describe() method provides a descriptive statistical values of a dataset. print ( heights . describe ()) # give statisical information about height data count 10000 .000000 mean 66 .367560 std 3 .847528 min 54 .263133 25 % 63 .505620 50 % 66 .318070 75 % 69 .174262 max 78 .998742 Name: Height, dtype: float64 print ( weights . describe ()) count 10000 .000000 mean 161 .440357 std 32 .108439 min 64 .700127 25 % 135 .818051 50 % 161 .212928 75 % 187 .169525 max 269 .989699 Name: Weight, dtype: float64 print ( df . describe ()) # describe can also give statistical information from a dataFrame Height Weight count 10000.000000 10000.000000 mean 66.367560 161.440357 std 3.847528 32.108439 min 54.263133 64.700127 25% 63.505620 135.818051 50% 66.318070 161.212928 75% 69.174262 187.169525 max 78.998742 269.989699 Similar to describe(), the info() method also give information about the dataset. Modifying a DataFrame Modifying a DataFrame: * We can create a new DataFrame * We can create a new column and add it to the DataFrame, * we can remove an existing column from a DataFrame, * we can modify an existing column in a DataFrame, * we can change the data type of column values in the DataFrame Creating a DataFrame As always, first we import the necessary packages. Now, lets import pandas and numpy, two best friends ever. import pandas as pd import numpy as np data = [ { \"Name\" : \"Asabeneh\" , \"Country\" : \"Finland\" , \"City\" : \"Helsinki\" }, { \"Name\" : \"David\" , \"Country\" : \"UK\" , \"City\" : \"London\" }, { \"Name\" : \"John\" , \"Country\" : \"Sweden\" , \"City\" : \"Stockholm\" }] df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsinki 1 David UK London 2 John Sweden Stockholm Adding a column to a DataFrame is like adding a key to a dictionary. First let's use the previous example to create a DataFrame. After we create the DataFrame, we will start modifying the columns and column values. Adding a New Column Let's add a weight column in the DataFrame weights = [ 74 , 78 , 69 ] df [ 'Weight' ] = weights df Name Country City Weight 0 Asabeneh Finland Helsinki 74 1 David UK London 78 2 John Sweden Stockholm 69 Let's add a height column into the DataFrame aswell heights = [ 173 , 175 , 169 ] df [ 'Height' ] = heights print ( df ) Name Country City Weight Height 0 Asabeneh Finland Helsinki 74 173 1 David UK London 78 175 2 John Sweden Stockholm 69 169 As you can see in the DataFrame above, we did add new columns, Weight and Height. Let's add one additional column called BMI(Body Mass Index) by calculating their BMI using thier mass and height. BMI is mass divided by height squared (in meters) - Weight/Height * Height. As you can see, the height is in centimeters, so we shoud change it to meters. Let's modify the height row. Modifying column values df [ 'Height' ] = df [ 'Height' ] * 0.01 df Name Country City Weight Height 0 Asabeneh Finland Helsinki 74 1.73 1 David UK London 78 1.75 2 John Sweden Stockholm 69 1.69 # Using functions makes our code clean, but you can calculate the bmi without one def calculate_bmi (): weights = df [ 'Weight' ] heights = df [ 'Height' ] bmi = [] for w , h in zip ( weights , heights ): b = w / ( h * h ) bmi . append ( b ) return bmi bmi = calculate_bmi () df [ 'BMI' ] = bmi df Name Country City Weight Height BMI 0 Asabeneh Finland Helsinki 74 1.73 24.725183 1 David UK London 78 1.75 25.469388 2 John Sweden Stockholm 69 1.69 24.158818 Formating DataFrame columns The BMI column values of the DataFrame are float with many significant digits after decimal. Let's change it to one significant digit after point. df [ 'BMI' ] = round ( df [ 'BMI' ], 1 ) print ( df ) Name Country City Weight Height BMI 0 Asabeneh Finland Helsinki 74 1.73 24.7 1 David UK London 78 1.75 25.5 2 John Sweden Stockholm 69 1.69 24.2 The information in the DataFrame seems not yet complete, let's add birth year and current year columns. birth_year = [ '1769' , '1985' , '1990' ] current_year = pd . Series ( 2020 , index = [ 0 , 1 , 2 ]) df [ 'Birth Year' ] = birth_year df [ 'Current Year' ] = current_year df Name Country City Weight Height BMI Birth Year Current Year 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2020 1 David UK London 78 1.75 25.5 1985 2020 2 John Sweden Stockholm 69 1.69 24.2 1990 2020 Checking data types of Column values print ( df . Weight . dtype ) dtype ( 'int64' ) df [ 'Birth Year' ] . dtype # it gives string object , we should change this to number df [ 'Birth Year' ] = df [ 'Birth Year' ] . astype ( 'int' ) print ( df [ 'Birth Year' ] . dtype ) # let's check the data type now dtype ( 'int32' ) Now same for the current year: df [ 'Current Year' ] = df [ 'Current Year' ] . astype ( 'int' ) df [ 'Current Year' ] . dtype dtype ( 'int32' ) Now, the column values of birth year and current year are integers. We can calculate the age. ages = df [ 'Current Year' ] - df [ 'Birth Year' ] ages 0 251 1 35 2 30 dtype: int32 df [ 'Ages' ] = ages print ( df ) Name Country City Weight Height BMI Birth Year Current Year Ages 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2019 250 1 David UK London 78 1.75 25.5 1985 2019 34 2 John Sweden Stockholm 69 1.69 24.2 1990 2019 29 The person in the first row lived so far for 251 years. It is unlikely for someone to live so long. Either it is a typo or the data is cooked. So lets fill that data with average of the columns without including outlier. mean = (35 + 30)/ 2 mean = ( 35 + 30 ) / 2 print ( 'Mean: ' , mean ) #it is good to add some description to the output, so we know what is what Mean: 32 .5 Boolean Indexing print ( df [ df [ 'Ages' ] > 120 ]) Name Country City Weight Height BMI Birth Year Current Year Ages 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2020 251 print ( df [ df [ 'Ages' ] < 120 ]) Name Country City Weight Height BMI Birth Year Current Year Ages 1 David UK London 78 1.75 25.5 1985 2020 35 2 John Sweden Stockholm 69 1.69 24.2 1990 2020 30 \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"Pandas"},{"location":"pandas/#installing-pandas","text":"For Mac: pip install conda conda install pandas For Windows: pip install conda pip install pandas Pandas data structure is based on Series and DataFrames . A series is a column and a DataFrame is a multidimensional table made up of collection of series . In order to create a pandas series we should use numpy to create a one dimensional arrays or a python list. Let us see an example of a series: Names Pandas Series Countries Series Cities Series As you can see, pandas series is just one column of data. If we want to have multiple columns we use data frames. The example below shows pandas DataFrames. Let us see, an example of a pandas data frame: Data frame is a collection of rows and columns. Look at the table below; it has many more columns than the example above: Next, we will see how to import pandas and how to create Series and DataFrames using pandas","title":"Installing Pandas"},{"location":"pandas/#importing-pandas","text":"import pandas as pd # importing pandas as pd import numpy as np # importing numpy as np","title":"Importing Pandas"},{"location":"pandas/#creating-pandas-series-with-default-index","text":"nums = [ 1 , 2 , 3 , 4 , 5 ] s = pd . Series ( nums ) print ( s ) 0 1 1 2 2 3 3 4 4 5 dtype: int64","title":"Creating Pandas Series with Default Index"},{"location":"pandas/#creating-pandas-series-with-custom-index","text":"nums = [ 1 , 2 , 3 , 4 , 5 ] s = pd . Series ( nums , index = [ 1 , 2 , 3 , 4 , 5 ]) print ( s ) 1 1 2 2 3 3 4 4 5 5 dtype: int64 fruits = [ 'Orange' , 'Banana' , 'Mango' ] fruits = pd . Series ( fruits , index = [ 1 , 2 , 3 ]) print ( fruits ) 1 Orange 2 Banana 3 Mango dtype: object","title":"Creating  Pandas Series with custom index"},{"location":"pandas/#creating-pandas-series-from-a-dictionary","text":"dct = { 'name' : 'Asabeneh' , 'country' : 'Finland' , 'city' : 'Helsinki' } s = pd . Series ( dct ) print ( s ) name Asabeneh country Finland city Helsinki dtype: object","title":"Creating Pandas Series from a Dictionary"},{"location":"pandas/#creating-a-constant-pandas-series","text":"s = pd . Series ( 10 , index = [ 1 , 2 , 3 ]) print ( s ) 1 10 2 10 3 10 dtype: int64","title":"Creating a Constant Pandas Series"},{"location":"pandas/#creating-a-pandas-series-using-linspace","text":"s = pd . Series ( np . linspace ( 5 , 20 , 10 )) # linspace(starting, end, items) print ( s ) 0 5 .000000 1 6 .666667 2 8 .333333 3 10 .000000 4 11 .666667 5 13 .333333 6 15 .000000 7 16 .666667 8 18 .333333 9 20 .000000 dtype: float64","title":"Creating a  Pandas Series Using Linspace"},{"location":"pandas/#dataframes","text":"Pandas data frames can be created in different ways.","title":"DataFrames"},{"location":"pandas/#creating-dataframes-from-list-of-lists","text":"data = [ [ 'Medo' , 'Finland' , 'Helsink' ], [ 'Joe' , 'UK' , 'London' ], [ 'Sarah' , 'Sweden' , 'Stockholm' ] ] df = pd . DataFrame ( data , columns = [ 'Names' , 'Country' , 'City' ]) print ( df ) Names Country City 0 Asabeneh Finland Helsink 1 David UK London 2 John Sweden Stockholm","title":"Creating DataFrames from List of Lists"},{"location":"pandas/#creating-dataframe-using-dictionary","text":"data = { 'Name' : [ 'Asabeneh' , 'David' , 'John' ], 'Country' :[ 'Finland' , 'UK' , 'Sweden' ], 'City' : [ 'Helsiki' , 'London' , 'Stockholm' ]} df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsiki 1 David UK London 2 John Sweden Stockholm","title":"Creating DataFrame Using Dictionary"},{"location":"pandas/#creating-dataframes-from-a-list-of-dictionaries","text":"data = [ { 'Name' : 'Asabeneh' , 'Country' : 'Finland' , 'City' : 'Helsinki' }, { 'Name' : 'David' , 'Country' : 'UK' , 'City' : 'London' }, { 'Name' : 'John' , 'Country' : 'Sweden' , 'City' : 'Stockholm' }] df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsinki 1 David UK London 2 John Sweden Stockholm","title":"Creating DataFrames from a List of Dictionaries"},{"location":"pandas/#reading-csv-file-using-pandas","text":"To download the CSV file, what is needed in this example, console/command line is enough: curl -O https://raw.githubusercontent.com/Asabeneh/30-Days-Of-Python/master/data/weight-height.csv Put the downloaded file in your working directory. import pandas as pd df = pd . read_csv ( 'weight-height.csv' ) print ( df )","title":"Reading CSV File Using Pandas"},{"location":"pandas/#data-exploration","text":"Let us read only the first 5 rows using head() print ( df . head ()) # give five rows we can increase the number of rows by passing argument to the head() method Gender Height Weight 0 Male 73.847017 241.893563 1 Male 68.781904 162.310473 2 Male 74.110105 212.740856 3 Male 71.730978 220.042470 4 Male 69.881796 206.349801 Let us also explore the last recordings of the dataframe using the tail() methods. print ( df . tail ()) # tails give the last five rows, we can increase the rows by passing argument to tail method Gender Height Weight 9995 Female 66.172652 136.777454 9996 Female 67.067155 170.867906 9997 Female 63.867992 128.475319 9998 Female 69.034243 163.852461 9999 Female 61.944246 113.649103 As you can see the csv file has three rows: Gender, Height and Weight. If the DataFrame would have a long rows, it would be hard to know all the columns. Therefore, we should use a method to know the colums. we do not know the number of rows. Let's use shape meathod. print ( df . shape ) # as you can see 10000 rows and three columns (10000, 3) Let us get all the columns using columns. print ( df . columns ) Index(['Gender', 'Height', 'Weight'], dtype='object') Now, let us get a specific column using the column key heights = df [ 'Height' ] # this is now a series print ( heights ) 0 73 .847017 1 68 .781904 2 74 .110105 3 71 .730978 4 69 .881796 ... 9995 66 .172652 9996 67 .067155 9997 63 .867992 9998 69 .034243 9999 61 .944246 Name: Height, Length: 10000 , dtype: float64 weights = df [ 'Weight' ] # this is now a series print ( weights ) 0 241 .893563 1 162 .310473 2 212 .740856 3 220 .042470 4 206 .349801 ... 9995 136 .777454 9996 170 .867906 9997 128 .475319 9998 163 .852461 9999 113 .649103 Name: Weight, Length: 10000 , dtype: float64 print ( len ( heights ) == len ( weights )) True The describe() method provides a descriptive statistical values of a dataset. print ( heights . describe ()) # give statisical information about height data count 10000 .000000 mean 66 .367560 std 3 .847528 min 54 .263133 25 % 63 .505620 50 % 66 .318070 75 % 69 .174262 max 78 .998742 Name: Height, dtype: float64 print ( weights . describe ()) count 10000 .000000 mean 161 .440357 std 32 .108439 min 64 .700127 25 % 135 .818051 50 % 161 .212928 75 % 187 .169525 max 269 .989699 Name: Weight, dtype: float64 print ( df . describe ()) # describe can also give statistical information from a dataFrame Height Weight count 10000.000000 10000.000000 mean 66.367560 161.440357 std 3.847528 32.108439 min 54.263133 64.700127 25% 63.505620 135.818051 50% 66.318070 161.212928 75% 69.174262 187.169525 max 78.998742 269.989699 Similar to describe(), the info() method also give information about the dataset.","title":"Data Exploration"},{"location":"pandas/#modifying-a-dataframe","text":"Modifying a DataFrame: * We can create a new DataFrame * We can create a new column and add it to the DataFrame, * we can remove an existing column from a DataFrame, * we can modify an existing column in a DataFrame, * we can change the data type of column values in the DataFrame","title":"Modifying a DataFrame"},{"location":"pandas/#creating-a-dataframe","text":"As always, first we import the necessary packages. Now, lets import pandas and numpy, two best friends ever. import pandas as pd import numpy as np data = [ { \"Name\" : \"Asabeneh\" , \"Country\" : \"Finland\" , \"City\" : \"Helsinki\" }, { \"Name\" : \"David\" , \"Country\" : \"UK\" , \"City\" : \"London\" }, { \"Name\" : \"John\" , \"Country\" : \"Sweden\" , \"City\" : \"Stockholm\" }] df = pd . DataFrame ( data ) print ( df ) Name Country City 0 Asabeneh Finland Helsinki 1 David UK London 2 John Sweden Stockholm Adding a column to a DataFrame is like adding a key to a dictionary. First let's use the previous example to create a DataFrame. After we create the DataFrame, we will start modifying the columns and column values.","title":"Creating a DataFrame"},{"location":"pandas/#adding-a-new-column","text":"Let's add a weight column in the DataFrame weights = [ 74 , 78 , 69 ] df [ 'Weight' ] = weights df Name Country City Weight 0 Asabeneh Finland Helsinki 74 1 David UK London 78 2 John Sweden Stockholm 69 Let's add a height column into the DataFrame aswell heights = [ 173 , 175 , 169 ] df [ 'Height' ] = heights print ( df ) Name Country City Weight Height 0 Asabeneh Finland Helsinki 74 173 1 David UK London 78 175 2 John Sweden Stockholm 69 169 As you can see in the DataFrame above, we did add new columns, Weight and Height. Let's add one additional column called BMI(Body Mass Index) by calculating their BMI using thier mass and height. BMI is mass divided by height squared (in meters) - Weight/Height * Height. As you can see, the height is in centimeters, so we shoud change it to meters. Let's modify the height row.","title":"Adding a New Column"},{"location":"pandas/#modifying-column-values","text":"df [ 'Height' ] = df [ 'Height' ] * 0.01 df Name Country City Weight Height 0 Asabeneh Finland Helsinki 74 1.73 1 David UK London 78 1.75 2 John Sweden Stockholm 69 1.69 # Using functions makes our code clean, but you can calculate the bmi without one def calculate_bmi (): weights = df [ 'Weight' ] heights = df [ 'Height' ] bmi = [] for w , h in zip ( weights , heights ): b = w / ( h * h ) bmi . append ( b ) return bmi bmi = calculate_bmi () df [ 'BMI' ] = bmi df Name Country City Weight Height BMI 0 Asabeneh Finland Helsinki 74 1.73 24.725183 1 David UK London 78 1.75 25.469388 2 John Sweden Stockholm 69 1.69 24.158818","title":"Modifying column values"},{"location":"pandas/#formating-dataframe-columns","text":"The BMI column values of the DataFrame are float with many significant digits after decimal. Let's change it to one significant digit after point. df [ 'BMI' ] = round ( df [ 'BMI' ], 1 ) print ( df ) Name Country City Weight Height BMI 0 Asabeneh Finland Helsinki 74 1.73 24.7 1 David UK London 78 1.75 25.5 2 John Sweden Stockholm 69 1.69 24.2 The information in the DataFrame seems not yet complete, let's add birth year and current year columns. birth_year = [ '1769' , '1985' , '1990' ] current_year = pd . Series ( 2020 , index = [ 0 , 1 , 2 ]) df [ 'Birth Year' ] = birth_year df [ 'Current Year' ] = current_year df Name Country City Weight Height BMI Birth Year Current Year 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2020 1 David UK London 78 1.75 25.5 1985 2020 2 John Sweden Stockholm 69 1.69 24.2 1990 2020","title":"Formating DataFrame columns"},{"location":"pandas/#checking-data-types-of-column-values","text":"print ( df . Weight . dtype ) dtype ( 'int64' ) df [ 'Birth Year' ] . dtype # it gives string object , we should change this to number df [ 'Birth Year' ] = df [ 'Birth Year' ] . astype ( 'int' ) print ( df [ 'Birth Year' ] . dtype ) # let's check the data type now dtype ( 'int32' ) Now same for the current year: df [ 'Current Year' ] = df [ 'Current Year' ] . astype ( 'int' ) df [ 'Current Year' ] . dtype dtype ( 'int32' ) Now, the column values of birth year and current year are integers. We can calculate the age. ages = df [ 'Current Year' ] - df [ 'Birth Year' ] ages 0 251 1 35 2 30 dtype: int32 df [ 'Ages' ] = ages print ( df ) Name Country City Weight Height BMI Birth Year Current Year Ages 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2019 250 1 David UK London 78 1.75 25.5 1985 2019 34 2 John Sweden Stockholm 69 1.69 24.2 1990 2019 29 The person in the first row lived so far for 251 years. It is unlikely for someone to live so long. Either it is a typo or the data is cooked. So lets fill that data with average of the columns without including outlier. mean = (35 + 30)/ 2 mean = ( 35 + 30 ) / 2 print ( 'Mean: ' , mean ) #it is good to add some description to the output, so we know what is what Mean: 32 .5","title":"Checking data types of Column values"},{"location":"pandas/#boolean-indexing","text":"print ( df [ df [ 'Ages' ] > 120 ]) Name Country City Weight Height BMI Birth Year Current Year Ages 0 Asabeneh Finland Helsinki 74 1.73 24.7 1769 2020 251 print ( df [ df [ 'Ages' ] < 120 ]) Name Country City Weight Height BMI Birth Year Current Year Ages 1 David UK London 78 1.75 25.5 1985 2020 35 2 John Sweden Stockholm 69 1.69 24.2 1990 2020 30 \ud83c\udf89 CONGRATULATIONS ! \ud83c\udf89","title":"Boolean Indexing"}]}